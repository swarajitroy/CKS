# Setup appropriate OS Leve security domains - PodSecurityPolicies, OPA, SecurityContext

## 01. PodSecurityPolicies
---

## 02. OPA
---
Its a CNCF project - https://www.openpolicyagent.org/ - focussed on ensuring simplicity in enforcing policies and a powerful yet very simplified policy authoring lifecycle. The Policy decision is made by OPA service - while Policy Enforcer can be anything. For example - a Spring Boot application in Java may use OPA to make some decisions but enforce it at the microservice level. The OPA service can run in many ways - a central service, a command line interpreter and a host of development, testing ecosystem of the policies. 

- When it comes to Kubernetes world - the policy enforcer is an admission controller. It works as a validating admission controller. So we configure a Validating Admission Controller in API server, with certificates and then run OPA itself as a Kubernetes Service and load Policy grammer (based on a DSL called REGO) is loaded as a ConfigMap. 
- We have a newer avatar of this - in form of OPA Gatekeeper for Kubernetes - which has more Kubernetes specific adoption (having a CRD concept and using a CRD named ConstraintTemplate  https://github.com/open-policy-agent/gatekeeper 
- A large library set https://github.com/open-policy-agent/gatekeeper-library

The way we can learn this subject is, 

- A. Use OPA and REGO as a standalone - without Kubernetes Integration
- B. Use OPA + Kubernetes API Server with Validating Admission Controller
- C. Use OPA gatekeeper

### 02.A  Use OPA and REGO as a standalone - without Kubernetes Integration
---


## 03. SecurityContext
---

A security context defines privilege and access control settings for a Pod or Container. It can be added in the Pod specification at a Pod spec level or Container level. These are some of the important facets on Security Context,

1. Discretionary Access Control: Permission to access an object, like a file, is based on user ID (UID) and group ID (GID).
2. Security Enhanced Linux (SELinux): Objects are assigned security labels.
3. Running as privileged or unprivileged.
4. Linux Capabilities: Give a process some privileges, but not all the privileges of the root user.
5. AppArmor: Use program profiles to restrict the capabilities of individual programs.
6. Seccomp: Filter a process's system calls.
7. AllowPrivilegeEscalation: Controls whether a process can gain more privileges than its parent process. This bool directly controls whether the no_new_privs flag gets set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged OR 2) has CAP_SYS_ADMIN.
8. readOnlyRootFilesystem: Mounts the container's root filesystem as read-only.

In this section - I will detail Discretionary Access Control, Running as privileged or unprivileged, Linux Capabilities & AllowPrivilegeEscalation. We will discuss AppArmour and Seccomp in Section C - System Hardening and readOnlyRootFilesystem will be detailed in Section F - Ensure Immutability of container at runtime. 

### Test Pod
---

Lets build a Pod using BusyBox with with a sleep 1 day command. 

```
ubuntu@ip-172-31-22-219:~$ cat venus-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: venus
  name: venus
spec:
  containers:
  - image: busybox
    name: venus
    command: ["sleep" , "1d"]
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}

ubuntu@ip-172-31-22-219:~$ kubectl create -f venus-pod.yaml
pod/venus created

ubuntu@ip-172-31-22-219:~$ kubectl get pods
NAME                             READY   STATUS    RESTARTS   AGE
venus                            1/1     Running   0          72s

ubuntu@ip-172-31-22-219:~$ kubectl exec -it venus -- /bin/sh
/ # ps -aef
PID   USER     TIME  COMMAND
    1 root      0:00 sleep 1d
    6 root      0:00 /bin/sh
   11 root      0:00 ps -aef

```

### Running the Pod as different user
---

As we can see - the venus pod runs as root. This root user is not the root user of the host server, but at a container level. To run it as a separate user,we need to use securityContext. 

```
ubuntu@ip-172-31-22-219:~$ cat venus-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: venus
  name: venus
spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
  containers:
  - image: busybox
    name: venus
    command: ["sleep" , "1d"]
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}

ubuntu@ip-172-31-22-219:~$ kubectl create -f venus-pod.yaml
pod/venus created

ubuntu@ip-172-31-22-219:~$ kubectl exec -it venus -- /bin/sh

~ $ ps -aef
PID   USER     TIME  COMMAND
    1 1000      0:00 sleep 1d
    6 1000      0:00 /bin/sh
   13 1000      0:00 ps -aef
~ $ touch /tmp/test.txt
~ $ ls -l /tmp/test.txt
-rw-r--r--    1 1000     3000             0 Jun  5 15:34 /tmp/test.txt

```

### Running the Pod with Linux Capability
---

### Running the Pod with previledged true
---
